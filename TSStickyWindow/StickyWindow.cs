using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using TSStickyWindow.Definitions;
using TSStickyWindow.Development;

namespace TSStickyWindow
{
    internal class StickyWindow
    {
        private readonly StickyWindowService service;
        private readonly StickyWindowOptions options;
        private readonly StickyWindowTestControls testControls;

        /// <summary>
        /// Unique Id of the StickyWindow object, currently it's generated by the StickyWindowService,
        /// but it can be passed from outside as well
        /// </summary>
        internal string Id { get; set; }

        #region Constructor

        public StickyWindow(StickyWindowService stickyService,
            StickyWindowOptions stickyOptions,
            Window window,
            string id,
            bool? testMode = null)
        {
            Id = id;
            service = stickyService;
            options = stickyOptions;

            if (testMode == true)
                testControls = new StickyWindowTestControls(this, window);

            this.window = window;

            this.window.LocationChanged += WindowOnLocationChanged;
            this.window.SizeChanged += WindowOnSizeChanged;
            this.window.Closing += WindowOnClosing;

            window.MinWidth = options.WindowMinWidth;
            window.MinHeight = options.WindowMinHeight;

            SetWindowControls();

            lblTitle.Content = Id;

            Stick = new Dictionary<StickPosition, StickyWindow>
            {
                [StickPosition.Top] = null,
                [StickPosition.Right] = null,
                [StickPosition.Bottom] = null,
                [StickPosition.Left] = null
            };

            this.window.Show();
        }

        #endregion


        #region Window & Control

        private Window window { get; }

        internal string GetWindowType()
        {
            return window.GetType().Name;
        }

        internal void SetWindowPosition(double left, double top)
        {
            window.Left = left;
            window.Top = top;
        }
        internal List<string> SetWindowPositionDiff(List<string> handledIds, double deltaX, double deltaY)
        {
            if (handledIds.Contains(Id))
                return handledIds;
            handledIds.Add(Id);

            SetWindowPosition(window.Left + deltaX, window.Top + deltaY);

            foreach (var (_, stickyWindow) in Stick.Where(s => s.Value is not null))
            {
                handledIds = stickyWindow.SetWindowPositionDiff(handledIds, deltaX, deltaY);
            }

            return handledIds;
        }

        private void UpdateWindowResizeMode()
        {
            // Option 1
            //window.ResizeMode = Stick.Values.Any(s => s != null) ? ResizeMode.NoResize : ResizeMode.CanResize;

            // Option 2
            var hasConnection = Stick.Values.Any(s => s != null);
            if (hasConnection)
            {
                window.MinWidth = window.Width;
                window.MaxWidth = window.Width;
                window.MinHeight = window.Height;
                window.MaxHeight = window.Height;
            }
            else
            {
                window.MinWidth = options.WindowMinWidth;
                window.MaxWidth = int.MaxValue;
                window.MinHeight = options.WindowMinHeight;
                window.MaxHeight = int.MaxValue;
            }
        }

        internal void ShowWindow()
        {
            window.Show();
        }
        internal void CloseWindow()
        {
            window.Close();
        }

        #endregion

        #region Window Position Controls (for testing)

        // Production controls
        private Label lblTitle;
        private Button btnUnstick;

        private void SetWindowControls()
        {
            try
            {
                // Production controls
                btnUnstick = window.FindName(options.ButtonUnstickName) as Button ?? new Button();
                btnUnstick.Click += StartUnstickWindows;

                lblTitle = window.FindName(options.LabelTitleName) as Label ?? new Label();

                // Custom event handlers
                lblTitle.PreviewMouseLeftButtonDown += LblTitleMouseLeftButtonDown;
            }
            catch (Exception e)
            {
                Debug.WriteLine(e);
            }
        }

        #endregion

        #region Window Events

        private bool isSticking;

        private void LblTitleMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (e.LeftButton == MouseButtonState.Released)
                return;

            SetLastWindowPosition();

            //Window.OnMouseLeftButtonDown(e);
            window.DragMove();

            isSticking = true;
            service.TryStickWithOtherWindows(this);
            isSticking = false;
        }

        private void WindowOnLocationChanged(object sender, EventArgs e)
        {
            testControls?.UpdatePositionLabels();

            if (window.IsActive)
                service.TryMagnetWithUnstickedWindows(this);

            if (!isSticking && window.IsActive)
            {
                var deltaX = window.Left - lastLeft;
                var deltaY = window.Top - lastTop;

                var handledIds = new List<string> { Id };
                foreach (var (_, stickyWindow) in Stick.Where(s => s.Value is not null))
                {
                    handledIds = stickyWindow.SetWindowPositionDiff(handledIds, deltaX, deltaY);
                }
            }

            SetLastWindowPosition();
        }

        private void WindowOnSizeChanged(object sender, SizeChangedEventArgs e)
        {
            if (!window.IsActive)
            {
                SetLastWindowPosition();
                return;
            }

            SetLastWindowPosition();
            testControls?.UpdatePositionLabels();
        }

        private void WindowOnClosing(object sender, CancelEventArgs e)
        {
            UnsticFromAllWindows();
            service.RemoveWindow(this);

            // Cleanup the events
            window.LocationChanged -= WindowOnLocationChanged;
            window.SizeChanged -= WindowOnSizeChanged;
            window.Closing -= WindowOnClosing;
        }

        #endregion

        #region Window Position

        private double lastLeft;
        private double lastTop;

        /// <summary>
        /// Call after Location change & Size change
        /// </summary>
        private void SetLastWindowPosition()
        {
            lastLeft = window.Left;
            lastTop = window.Top;
        }

        public double Left => window.Left;
        public double Right => window.Left + window.Width;
        public double Top => window.Top;
        public double Bottom => window.Top + window.Height;

        public double Width => window.Width;
        public double Height => window.Height;

        #endregion

        #region Sticked Windows Management

        internal Dictionary<StickPosition, StickyWindow> Stick { get; set; }

        internal bool CanStickWindow(StickyWindow source, StickPosition position)
        {
            if (Stick.ContainsValue(source))
                return false;

            if (Stick[position] is not null)
                return false;

            return true;
        }
        // !! Use after the CanStickWindow validation !!
        internal void StickWindow(StickyWindow targetWindow, StickPosition position, bool arrange = false)
        {
            Stick[position] = targetWindow;

            if (arrange)
            {
                if (position == StickPosition.Top)
                    window.Top = targetWindow.Bottom;
                
                else if (position == StickPosition.Right)
                    window.Left = targetWindow.Left - window.Width;
                
                else if (position == StickPosition.Bottom)
                    window.Top = targetWindow.Top - window.Height;
                
                else if (position == StickPosition.Left)
                    window.Left = targetWindow.Right;
            }

            UpdateWindowResizeMode();

            HighlightStickState();
        }

        /// <summary>
        /// Called from the Source window, to unstick it from the target, based on the relative Position
        /// </summary>
        /// <param name="position"></param>
        internal void UnstickWindow(StickPosition position)
        {
            Stick[position] = null;

            UpdateWindowResizeMode();

            HighlightStickState();
        }
        internal void UnsticFromAllWindows()
        {
            Stick[StickPosition.Top]?.UnstickWindow(StickPosition.Bottom);
            Stick[StickPosition.Right]?.UnstickWindow(StickPosition.Left);
            Stick[StickPosition.Bottom]?.UnstickWindow(StickPosition.Top);
            Stick[StickPosition.Left]?.UnstickWindow(StickPosition.Right);

            service.InvokeWindowsUnsticked(Id, 
                Stick[StickPosition.Top]?.Id ?? "", 
                Stick[StickPosition.Right]?.Id ?? "",
                Stick[StickPosition.Bottom]?.Id ?? "", 
                Stick[StickPosition.Left]?.Id ?? ""
            );

            Stick[StickPosition.Top] = null;
            Stick[StickPosition.Right] = null;
            Stick[StickPosition.Bottom] = null;
            Stick[StickPosition.Left] = null;

            UpdateWindowResizeMode();

            HighlightStickState();
        }

        private void HighlightStickState()
        {
            testControls?.HighlightStickState();

            btnUnstick.Visibility = Stick.Values.Any(s => s != null) ? Visibility.Visible : Visibility.Collapsed;
        }

        private void StartUnstickWindows(object sender, RoutedEventArgs e)
        {
            UnsticFromAllWindows();
        }

        #endregion

        #region Magnet

        internal void SetMagnetPosition(double? top, double? right, double? bottom, double? left)
        {
            if (top is not null)
                window.Top = top.Value;
            else if (right is not null)
                window.Left = right.Value - Width;
            else if (bottom is not null)
                window.Top = bottom.Value - Height;
            else if (left is not null)
                window.Left = left.Value;
        }

        #endregion
    }
}